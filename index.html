<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tournament Tree - Knockout System</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
        padding: 20px;
        overflow-x: auto;
      }

      .container {
        text-align: center;
        margin-bottom: 30px;
      }

      h1 {
        color: white;
        font-size: 2.5rem;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .description {
        color: rgba(255, 255, 255, 0.9);
        max-width: 600px;
        margin: 0 auto;
        line-height: 1.6;
      }

      .slider-container {
        margin: 20px 0;
        text-align: center;
      }

      .slider-label {
        color: white;
        font-size: 1.2rem;
        margin-bottom: 10px;
        display: block;
      }

      .tournament-slider {
        width: 300px;
        height: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.3);
        outline: none;
        -webkit-appearance: none;
        margin: 10px 0;
      }

      .tournament-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .tournament-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .round-info {
        color: rgba(255, 255, 255, 0.9);
        font-size: 1.1rem;
        margin: 10px 0;
      }

      .tree-container {
        position: relative;
        width: 1200px;
        height: 600px;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .node {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        position: absolute;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.5s ease;
        font-size: 1.2rem;
        z-index: 10;
        border: 3px solid white;
        opacity: 0;
      }

      .node.visible {
        opacity: 1;
        transform: scale(1);
      }

      .node.winner {
        animation: pulse 1s ease-in-out;
        box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.7);
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      .node:hover.visible {
        transform: scale(1.1);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      }

      .root {
        background-color: #2196f3;
        top: 50%;
        left: 50%;
      
      }

      /* Left side nodes (A branch) */
      .node-a {
        background-color: #ff9800;
        top: 50%;
        left: 30%;
       
      }

      .node-a1 {
        background-color: #4caf50;
        top: 30%;
        left: 20%;
      }

      .node-a2 {
        background-color: #f44336;
        top: 70%;
        left: 20%;
      }

      .node-a1-1 {
        background-color: #00bcd4;
        top: 20%;
        left: 10%;
      }

      .node-a1-2 {
        background-color: #e91e63;
        top: 40%;
        left: 10%;
      }

      .node-a2-1 {
        background-color: #ff5722;
        top: 60%;
        left: 10%;
      }

      .node-a2-2 {
        background-color: #607d8b;
        top: 80%;
        left: 10%;
      }

      .node-a1-1-1 {
        background-color: #8bc34a;
        top: 15%;
        left: 5%;
      }

      .node-a1-1-2 {
        background-color: #795548;
        top: 25%;
        left: 5%;
      }

      .node-a1-2-1 {
        background-color: #009688;
        top: 35%;
        left: 5%;
      }

      .node-a1-2-2 {
        background-color: #673ab7;
        top: 45%;
        left: 5%;
      }

      .node-a2-1-1 {
        background-color: #3f51b5;
        top: 55%;
        left: 5%;
      }

      .node-a2-1-2 {
        background-color: #ffc107;
        top: 65%;
        left: 5%;
      }

      .node-a2-2-1 {
        background-color: #cddc39;
        top: 75%;
        left: 5%;
      }

      .node-a2-2-2 {
        background-color: #ff9800;
        top: 85%;
        left: 5%;
      }

      /* Right side nodes (B branch) */
      .node-b {
        background-color: #9c27b0;
        top: 50%;
        left: 70%;
      
      }

      .node-b1 {
        background-color: #4caf50;
        top: 30%;
        left: 80%;
      }

      .node-b2 {
        background-color: #f44336;
        top: 70%;
        left: 80%;
      }

      .node-b1-1 {
        background-color: #00bcd4;
        top: 20%;
        left: 90%;
      }

      .node-b1-2 {
        background-color: #e91e63;
        top: 40%;
        left: 90%;
      }

      .node-b2-1 {
        background-color: #ff5722;
        top: 60%;
        left: 90%;
      }

      .node-b2-2 {
        background-color: #607d8b;
        top: 80%;
        left: 90%;
      }

      .node-b1-1-1 {
        background-color: #8bc34a;
        top: 15%;
        left: 95%;
      }

      .node-b1-1-2 {
        background-color: #795548;
        top: 25%;
        left: 95%;
      }

      .node-b1-2-1 {
        background-color: #009688;
        top: 35%;
        left: 95%;
      }

      .node-b1-2-2 {
        background-color: #673ab7;
        top: 45%;
        left: 95%;
      }

      .node-b2-1-1 {
        background-color: #3f51b5;
        top: 55%;
        left: 95%;
      }

      .node-b2-1-2 {
        background-color: #ffc107;
        top: 65%;
        left: 95%;
      }

      .node-b2-2-1 {
        background-color: #cddc39;
        top: 75%;
        left: 95%;
      }

      .node-b2-2-2 {
        background-color: #ff9800;
        top: 85%;
        left: 95%;
      }

      svg {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1;
      }

      line {
        stroke: white;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 1;
        transition: opacity 0.5s ease;
      }

      line.visible {
        opacity: 1;
      }

      line.level-4 { opacity: 1; }
      line.level-3 { opacity: 1; }
      line.level-2 { opacity: 1; }
      line.level-1 { opacity: 1; }
      line.level-0 { opacity: 1; }

      line.hidden {
        opacity: 0;
      }

      path {
        fill: none;
        stroke: white;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 1;
        transition: opacity 0.5s ease;
      }

      path.visible {
        opacity: 1;
      }

      path.level-4 { opacity: 1; }
      path.level-3 { opacity: 1; }
      path.level-2 { opacity: 1; }
      path.level-1 { opacity: 1; }
      path.level-0 { opacity: 1; }

      path.hidden {
        opacity: 0;
      }

      .controls {
        margin-top: 30px;
        display: flex;
        gap: 15px;
      }

      button {
        padding: 12px 25px;
        border: none;
        border-radius: 30px;
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-3px);
      }

      .instructions {
        margin-top: 20px;
        color: rgba(255, 255, 255, 0.8);
        text-align: center;
        max-width: 600px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Tournament Tree - Knockout System</h1>
      <p class="description">
        Use the slider to progress through tournament rounds. Winners advance to
        the next level!
      </p>
    </div>

    <div class="slider-container">
      <label class="slider-label">Tournament Round</label>
      <input
        type="range"
        min="0"
        max="4"
        value="0"
        class="tournament-slider"
        id="roundSlider"
      />
      <div class="round-info" id="roundInfo">
        Round 1: Leaf Nodes (16 competitors)
      </div>
    </div>

    <div class="slider-container">
      <label class="slider-label">Path Visibility</label>
      <input
        type="range"
        min="0"
        max="4"
        value="0"
        class="tournament-slider"
        id="pathSlider"
      />
      <div class="round-info" id="pathInfo">
        All paths visible
      </div>
    </div>

    <div class="tree-container">
      <svg id="tree-svg"></svg>

      <!-- Root node -->
      <div class="node root" data-level="0">X</div>

      <!-- Level 1 nodes -->
      <div class="node node-a" data-level="1">A</div>
      <div class="node node-b" data-level="1">B</div>

      <!-- Level 2 nodes (children of A and B) -->
      <div class="node node-a1" data-level="2">A1</div>
      <div class="node node-a2" data-level="2">A2</div>
      <div class="node node-b1" data-level="2">B1</div>
      <div class="node node-b2" data-level="2">B2</div>

      <!-- Level 3 nodes -->
      <div class="node node-a1-1" data-level="3">A1-1</div>
      <div class="node node-a1-2" data-level="3">A1-2</div>
      <div class="node node-a2-1" data-level="3">A2-1</div>
      <div class="node node-a2-2" data-level="3">A2-2</div>

      <div class="node node-b1-1" data-level="3">B1-1</div>
      <div class="node node-b1-2" data-level="3">B1-2</div>
      <div class="node node-b2-1" data-level="3">B2-1</div>
      <div class="node node-b2-2" data-level="3">B2-2</div>

      <!-- Level 4 nodes (leaf nodes) -->
      <div class="node node-a1-1-1" data-level="4">A1-1-1</div>
      <div class="node node-a1-1-2" data-level="4">A1-1-2</div>
      <div class="node node-a1-2-1" data-level="4">A1-2-1</div>
      <div class="node node-a1-2-2" data-level="4">A1-2-2</div>
      <div class="node node-a2-1-1" data-level="4">A2-1-1</div>
      <div class="node node-a2-1-2" data-level="4">A2-1-2</div>
      <div class="node node-a2-2-1" data-level="4">A2-2-1</div>
      <div class="node node-a2-2-2" data-level="4">A2-2-2</div>

      <div class="node node-b1-1-1" data-level="4">B1-1-1</div>
      <div class="node node-b1-1-2" data-level="4">B1-1-2</div>
      <div class="node node-b1-2-1" data-level="4">B1-2-1</div>
      <div class="node node-b1-2-2" data-level="4">B1-2-2</div>
      <div class="node node-b2-1-1" data-level="4">B2-1-1</div>
      <div class="node node-b2-1-2" data-level="4">B2-1-2</div>
      <div class="node node-b2-2-1" data-level="4">B2-2-1</div>
      <div class="node node-b2-2-2" data-level="4">B2-2-2</div>
    </div>

    <div class="controls">
      <button id="reset-tournament">Reset Tournament</button>
      <button id="auto-play">Auto Play</button>
    </div>

    <div class="instructions">
      <p>
        Move the slider to advance through tournament rounds. Each round,
        winners are randomly selected to advance to the next level. The
        tournament continues until either A or B reaches the root position X.
      </p>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const svg = document.getElementById("tree-svg");
        const slider = document.getElementById("roundSlider");
        const roundInfo = document.getElementById("roundInfo");
        const pathSlider = document.getElementById("pathSlider");
        const pathInfo = document.getElementById("pathInfo");
        const resetBtn = document.getElementById("reset-tournament");
        const autoPlayBtn = document.getElementById("auto-play");

        let currentRound = 0;
        let pathVisibilityLevel = 0;
        let winners = {}; // Store winners for each round
        let isAutoPlaying = false;

        // Get all nodes
        const nodes = {};
        document.querySelectorAll(".node").forEach((node) => {
          const classList = Array.from(node.classList);
          const nodeClass = classList.find((cls) => cls !== "node");
          nodes[nodeClass] = node;
        });

        // Define the tournament structure
        const tournamentStructure = {
          4: [
            "node-a1-1-1",
            "node-a1-1-2",
            "node-a1-2-1",
            "node-a1-2-2",
            "node-a2-1-1",
            "node-a2-1-2",
            "node-a2-2-1",
            "node-a2-2-2",
            "node-b1-1-1",
            "node-b1-1-2",
            "node-b1-2-1",
            "node-b1-2-2",
            "node-b2-1-1",
            "node-b2-1-2",
            "node-b2-2-1",
            "node-b2-2-2",
          ],
          3: [
            "node-a1-1",
            "node-a1-2",
            "node-a2-1",
            "node-a2-2",
            "node-b1-1",
            "node-b1-2",
            "node-b2-1",
            "node-b2-2",
          ],
          2: ["node-a1", "node-a2", "node-b1", "node-b2"],
          1: ["node-a", "node-b"],
          0: ["root"],
        };

        // Define level mapping for paths based on child node level
        const pathLevels = {
          "root-node-a": 0,
          "root-node-b": 0,
          "node-a-node-a1": 1,
          "node-a-node-a2": 1,
          "node-b-node-b1": 1,
          "node-b-node-b2": 1,
          "node-a1-node-a1-1": 2,
          "node-a1-node-a1-2": 2,
          "node-a2-node-a2-1": 2,
          "node-a2-node-a2-2": 2,
          "node-b1-node-b1-1": 2,
          "node-b1-node-b1-2": 2,
          "node-b2-node-b2-1": 2,
          "node-b2-node-b2-2": 2,
          "node-a1-1-node-a1-1-1": 3,
          "node-a1-1-node-a1-1-2": 3,
          "node-a1-2-node-a1-2-1": 3,
          "node-a1-2-node-a1-2-2": 3,
          "node-a2-1-node-a2-1-1": 3,
          "node-a2-1-node-a2-1-2": 3,
          "node-a2-2-node-a2-2-1": 3,
          "node-a2-2-node-a2-2-2": 3,
          "node-b1-1-node-b1-1-1": 3,
          "node-b1-1-node-b1-1-2": 3,
          "node-b1-2-node-b1-2-1": 3,
          "node-b1-2-node-b1-2-2": 3,
          "node-b2-1-node-b2-1-1": 3,
          "node-b2-1-node-b2-1-2": 3,
          "node-b2-2-node-b2-2-1": 3,
          "node-b2-2-node-b2-2-2": 3
        };

        // i created a function to get path level from node relationships
        function getPathLevel(parent, child) {
          // level 4 connections (leaf to level 3)
          if (child.includes('-1-1') || child.includes('-2-1') || child.includes('-1-2') || child.includes('-2-2')) {
            return 4;
          }
          // level 3 connections (level 3 to level 2)
          if (child.includes('-1') || child.includes('-2')) {
            if (!child.includes('-1-') && !child.includes('-2-')) {
              return 3;
            }
          }
          // level 2 connections (level 2 to level 1)
          if ((child === 'node-a1' || child === 'node-a2' || child === 'node-b1' || child === 'node-b2')) {
            return 2;
          }
          // level 1 connections (level 1 to root)
          if (child === 'node-a' || child === 'node-b') {
            return 1;
          }
          return 0;
        }

        // i created a function to get node level from node class
        function getNodeLevel(nodeClass) {
          if (nodeClass === 'root') {
            return 0;
          }
          if (nodeClass === 'node-a' || nodeClass === 'node-b') {
            return 1;
          }
          if (nodeClass === 'node-a1' || nodeClass === 'node-a2' || nodeClass === 'node-b1' || nodeClass === 'node-b2') {
            return 2;
          }
          if (nodeClass.includes('-1') || nodeClass.includes('-2')) {
            if (!nodeClass.includes('-1-') && !nodeClass.includes('-2-')) {
              return 3;
            }
          }
          if (nodeClass.includes('-1-1') || nodeClass.includes('-2-1') || nodeClass.includes('-1-2') || nodeClass.includes('-2-2')) {
            return 4;
          }
          return 4;
        }

        // Define parent-child relationships for connections
        const relationships = [
          { parent: "root", child: "node-a" },
          { parent: "root", child: "node-b" },
          { parent: "node-a", child: "node-a1" },
          { parent: "node-a", child: "node-a2" },
          { parent: "node-b", child: "node-b1" },
          { parent: "node-b", child: "node-b2" },
          { parent: "node-a1", child: "node-a1-1" },
          { parent: "node-a1", child: "node-a1-2" },
          { parent: "node-a2", child: "node-a2-1" },
          { parent: "node-a2", child: "node-a2-2" },
          { parent: "node-b1", child: "node-b1-1" },
          { parent: "node-b1", child: "node-b1-2" },
          { parent: "node-b2", child: "node-b2-1" },
          { parent: "node-b2", child: "node-b2-2" },
          { parent: "node-a1-1", child: "node-a1-1-1" },
          { parent: "node-a1-1", child: "node-a1-1-2" },
          { parent: "node-a1-2", child: "node-a1-2-1" },
          { parent: "node-a1-2", child: "node-a1-2-2" },
          { parent: "node-a2-1", child: "node-a2-1-1" },
          { parent: "node-a2-1", child: "node-a2-1-2" },
          { parent: "node-a2-2", child: "node-a2-2-1" },
          { parent: "node-a2-2", child: "node-a2-2-2" },
          { parent: "node-b1-1", child: "node-b1-1-1" },
          { parent: "node-b1-1", child: "node-b1-1-2" },
          { parent: "node-b1-2", child: "node-b1-2-1" },
          { parent: "node-b1-2", child: "node-b1-2-2" },
          { parent: "node-b2-1", child: "node-b2-1-1" },
          { parent: "node-b2-1", child: "node-b2-1-2" },
          { parent: "node-b2-2", child: "node-b2-2-1" },
          { parent: "node-b2-2", child: "node-b2-2-2" },
        ];

        function updateRoundInfo(round) {
          const roundNames = [
            "All nodes visible",
            "Level 4 nodes hidden (leaf nodes)",
            "Level 3-4 nodes hidden",
            "Level 2-4 nodes hidden",
            "Only root node visible"
          ];
          roundInfo.textContent = roundNames[round] || "All nodes hidden";
        }

        function updateNodeVisibility(level) {
          // i implemented this to control which node levels are visible based on the slider
          Object.values(nodes).forEach(node => {
            const classList = Array.from(node.classList);
            const nodeClass = classList.find(cls => cls !== 'node' && cls !== 'visible' && cls !== 'winner');
            
            if (nodeClass) {
              const nodeLevel = getNodeLevel(nodeClass);
              
              // remove existing classes
              node.classList.remove('visible', 'winner');
              
              // show nodes from root level down to the specified level
              // level 0 = all visible, level 1 = hide level 4, level 2 = hide level 3&4, etc.
              if (nodeLevel <= (4 - level)) {
                node.classList.add('visible');
              }
            }
          });
        }

        function updatePathInfo(level) {
          const pathNames = [
            "All paths visible",
            "Level 4 paths hidden (leaf connections)",
            "Level 3-4 paths hidden",
            "Level 2-4 paths hidden",
            "Only root paths visible"
          ];
          pathInfo.textContent = pathNames[level] || "All paths hidden";
        }

        function updatePathVisibility(level) {
          // i implemented this to control which path levels are visible based on the slider
          document.querySelectorAll('line, path').forEach(connection => {
            const parent = connection.getAttribute('data-parent');
            const child = connection.getAttribute('data-child');
            
            if (parent && child) {
              const pathLevel = getPathLevel(parent, child);
              
              // remove existing level classes and hidden class
              connection.classList.remove('hidden', 'level-0', 'level-1', 'level-2', 'level-3', 'level-4');
              connection.classList.add(`level-${pathLevel}`);
              
              // hide paths from highest level (4) down to the specified level
              // level 0 = all visible, level 1 = hide level 4, level 2 = hide level 3&4, etc.
              if (pathLevel > (4 - level)) {
                connection.classList.add('hidden');
              }
            }
          });
          
          updatePathInfo(level);
        }

        function selectWinners(currentLevel, nextLevel) {
          // Group current level nodes by their parent
          const groups = {};

          relationships.forEach((rel) => {
            if (tournamentStructure[nextLevel].includes(rel.parent)) {
              if (!groups[rel.parent]) {
                groups[rel.parent] = [];
              }
              if (tournamentStructure[currentLevel].includes(rel.child)) {
                groups[rel.parent].push(rel.child);
              }
            }
          });

          // Select one winner from each group
          const winners = [];
          Object.keys(groups).forEach((parent) => {
            const candidates = groups[parent];
            if (candidates.length > 0) {
              const winner =
                candidates[Math.floor(Math.random() * candidates.length)];
              winners.push({ winner, parent, candidates });
            }
          });

          return winners;
        }

        function updateTournament(round) {
          // i simplified this to only control node visibility by levels
          updateNodeVisibility(round);
          drawConnections();
          updateRoundInfo(round);
        }

        function progressTournament(targetRound) {
          for (let round = currentRound + 1; round <= targetRound; round++) {
            if (round <= 4) {
              const currentLevel = 5 - round;
              const nextLevel = currentLevel - 1;

              if (nextLevel >= 0) {
                winners[round] = selectWinners(currentLevel, nextLevel);
              }
            }
          }
          currentRound = targetRound;
          updateTournament(currentRound);
        }

        // Slider event listeners
        slider.addEventListener("input", (e) => {
          if (!isAutoPlaying) {
            const targetRound = parseInt(e.target.value);
            currentRound = targetRound;
            updateTournament(currentRound);
          }
        });

        pathSlider.addEventListener("input", (e) => {
          pathVisibilityLevel = parseInt(e.target.value);
          updatePathVisibility(pathVisibilityLevel);
        });

        function resetTournament() {
          currentRound = 0;
          winners = {};
          slider.value = 0;
          pathSlider.value = 0;
          pathVisibilityLevel = 0;
          updateTournament(0);
          drawConnections();
          updatePathVisibility(0);
        }

        function drawConnections() {
          svg.innerHTML = "";

          relationships.forEach((rel) => {
            const parentNode = nodes[rel.parent];
            const childNode = nodes[rel.child];

            if (!parentNode || !childNode) return;

            const parentRect = parentNode.getBoundingClientRect();
            const childRect = childNode.getBoundingClientRect();
            const containerRect = svg.getBoundingClientRect();

            const parentCenter = {
              x: parentRect.left + parentRect.width / 2 - containerRect.left,
              y: parentRect.top + parentRect.height / 2 - containerRect.top,
            };

            const childCenter = {
              x: childRect.left + childRect.width / 2 - containerRect.left,
              y: childRect.top + childRect.height / 2 - containerRect.top,
            };

            let element;
            if (rel.parent === "root") {
              element = drawStraightLine(parentCenter, childCenter);
            } else {
              element = drawLShapedLine(parentCenter, childCenter);
            }

            element.setAttribute("data-parent", rel.parent);
            element.setAttribute("data-child", rel.child);
            
            // i added level classification for path visibility control
            const pathLevel = getPathLevel(rel.parent, rel.child);
            element.classList.add(`level-${pathLevel}`);
          });
        }

        function drawLShapedLine(from, to) {
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          const isLeftSide = to.x < from.x;

          let pathData;
          if (isLeftSide) {
            const midX = from.x - Math.abs(from.x - to.x) * 0.5;
            pathData = `M ${from.x} ${from.y} H ${midX} V ${to.y} H ${to.x}`;
          } else {
            const midX = from.x + Math.abs(from.x - to.x) * 0.5;
            pathData = `M ${from.x} ${from.y} H ${midX} V ${to.y} H ${to.x}`;
          }

          path.setAttribute("d", pathData);
          svg.appendChild(path);
          return path;
        }

        function drawStraightLine(from, to) {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", from.x);
          line.setAttribute("y1", from.y);
          line.setAttribute("x2", to.x);
          line.setAttribute("y2", to.y);
          svg.appendChild(line);
          return line;
        }

        // Reset button
        resetBtn.addEventListener("click", resetTournament);

        // Auto play functionality
        autoPlayBtn.addEventListener("click", () => {
          if (isAutoPlaying) {
            isAutoPlaying = false;
            autoPlayBtn.textContent = "Auto Play";
          } else {
            isAutoPlaying = true;
            autoPlayBtn.textContent = "Stop";
            autoPlay();
          }
        });

        function autoPlay() {
          if (!isAutoPlaying || currentRound >= 4) {
            isAutoPlaying = false;
            autoPlayBtn.textContent = "Auto Play";
            return;
          }

          setTimeout(() => {
            slider.value = currentRound + 1;
            progressTournament(currentRound + 1);
            if (isAutoPlaying) {
              autoPlay();
            }
          }, 1500);
        }

        // Initialize
        resetTournament();
      });
    </script>
  </body>
</html>
