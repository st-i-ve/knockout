<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tournament Tree - Knockout System</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100dvh;
        background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
        padding: 10px;
        overflow-x: auto;
      }

      .container {
        text-align: center;
        margin-bottom: 30px;
      }

      h1 {
        color: white;
        font-size: 2.5rem;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .description {
        color: rgba(255, 255, 255, 0.9);
        max-width: 600px;
        margin: 0 auto;
        line-height: 1.6;
      }

      .slider-container {
        margin: 20px 0;
        text-align: center;
      }

      .slider-label {
        color: white;
        font-size: 1.2rem;
        margin-bottom: 10px;
        display: block;
      }

      .tournament-slider {
        width: 300px;
        height: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.3);
        outline: none;
        -webkit-appearance: none;
        margin: 10px 0;
      }

      .tournament-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .tournament-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .round-info {
        color: rgba(255, 255, 255, 0.9);
        font-size: 1.1rem;
        margin: 10px 0;
      }

      /* RESPONSIVE container */
      .tree-container {
        position: relative; /* already present but be explicit */
        width: 100%;
        max-width: 1200px;      /* keep desktop max */
        aspect-ratio: 1 / 1;    /* keeps 1200x600 proportions and scales */
        min-height: 300px;      /* fallback for older browsers */
        background-color: rgba(255, 255, 255, 0.1);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      /* center each node at its top/left coordinates */
      .node {
        width: 100px;
        height: 32px;
        border-radius: 6px;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        position: absolute;
        z-index: 10;
        border: 1px solid white;
        opacity: 0;
        /* center: translate + scale(1) default so later scale keeps the translate */
        transform: translate(-50%, -50%) scale(1);
        transition: transform 0.35s ease, opacity 0.35s ease, box-shadow 0.35s ease;
        font-size: 0.75rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        text-align: center;
        padding: 2px;
      }

      /* visible node keeps the translate but sets scale (so scale works together) */
      .node.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }

      /* hover grows while still centered */
      .node:hover.visible {
        transform: translate(-50%, -50%) scale(1.08);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      }

      /* winner pulse - include translate to preserve positioning while animating scale */
      .node.winner {
        animation: pulse 1s ease-in-out;
        box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.7);
      }

      @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.15); }
        100% { transform: translate(-50%, -50%) scale(1); }
      }

      .root {
        background-color: #2196f3;
        top: 50%;
        left: 50%;
      }

      /* Left side nodes (A branch) */
      .node-a {
        background-color: #ff9800;
        top: 50%;
        left: 36%;
      }

      .node-a1 {
        background-color: #4caf50;
        top: 30%;
        left: 32%;
      }

      .node-a2 {
        background-color: #f44336;
        top: 70%;
        left: 32%;
      }

      .node-a1-1 {
        background-color: #00bcd4;
        top: 20%;
        left: 30%;
      }

      .node-a1-2 {
        background-color: #e91e63;
        top: 40%;
        left: 30%;
      }

      .node-a2-1 {
        background-color: #ff5722;
        top: 60%;
        left: 30%;
      }

      .node-a2-2 {
        background-color: #607d8b;
        top: 80%;
        left: 30%;
      }

      .node-a1-1-1 {
        background-color: #8bc34a;
        top: 15%;
        left: 12%;
      }

      .node-a1-1-2 {
        background-color: #795548;
        top: 25%;
        left: 12%;
      }

      .node-a1-2-1 {
        background-color: #009688;
        top: 35%;
        left: 12%;
      }

      .node-a1-2-2 {
        background-color: #673ab7;
        top: 45%;
        left: 12%;
      }

      .node-a2-1-1 {
        background-color: #3f51b5;
        top: 55%;
        left: 12%;
      }

      .node-a2-1-2 {
        background-color: #ffc107;
        top: 65%;
        left: 12%;
      }

      .node-a2-2-1 {
        background-color: #cddc39;
        top: 75%;
        left: 12%;
      }

      .node-a2-2-2 {
        background-color: #ff9800;
        top: 85%;
        left: 12%;
      }

      /* Right side nodes (B branch) */
      .node-b {
        background-color: #9c27b0;
        top: 50%;
        left: 64%;
      }

      .node-b1 {
        background-color: #4caf50;
        top: 30%;
        left: 68%;
      }

      .node-b2 {
        background-color: #f44336;
        top: 70%;
        left: 68%;
      }

      .node-b1-1 {
        background-color: #00bcd4;
        top: 20%;
        left: 70%;
      }

      .node-b1-2 {
        background-color: #e91e63;
        top: 40%;
        left: 70%;
      }

      .node-b2-1 {
        background-color: #ff5722;
        top: 60%;
        left: 70%;
      }

      .node-b2-2 {
        background-color: #607d8b;
        top: 80%;
        left: 70%;
      }

      .node-b1-1-1 {
        background-color: #8bc34a;
        top: 15%;
        left: 88%;
      }

      .node-b1-1-2 {
        background-color: #795548;
        top: 25%;
        left: 88%;
      }

      .node-b1-2-1 {
        background-color: #009688;
        top: 35%;
        left: 88%;
      }

      .node-b1-2-2 {
        background-color: #673ab7;
        top: 45%;
        left: 88%;
      }

      .node-b2-1-1 {
        background-color: #3f51b5;
        top: 55%;
        left: 88%;
      }

      .node-b2-1-2 {
        background-color: #ffc107;
        top: 65%;
        left: 88%;
      }

      .node-b2-2-1 {
        background-color: #cddc39;
        top: 75%;
        left: 88%;
      }

      .node-b2-2-2 {
        background-color: #ff9800;
        top: 85%;
        left: 88%;
      }

      svg {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1;
      }

      line {
        stroke: white;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 1;
      }

      line.visible {
        opacity: 1;
      }

      line.level-4 {
        opacity: 1;
      }
      line.level-3 {
        opacity: 1;
      }
      line.level-2 {
        opacity: 1;
      }
      line.level-1 {
        opacity: 1;
      }
      line.level-0 {
        opacity: 1;
      }

      line.hidden {
        opacity: 0;
      }

      path {
        fill: none;
        stroke: white;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 1;
      }

      path.visible {
        opacity: 1;
      }

      path.level-4 {
        opacity: 1;
      }
      path.level-3 {
        opacity: 1;
      }
      path.level-2 {
        opacity: 1;
      }
      path.level-1 {
        opacity: 1;
      }
      path.level-0 {
        opacity: 1;
      }

      path.hidden {
        opacity: 0;
      }

      /* smaller screens - scale node sizes & font, reduce stroke width */
      @media (max-width: 600px) {
        .node { width: 80px; height: 26px; font-size: 0.65rem; border-width: 1px; padding: 1px; }
        .tournament-slider { width: 200px; }
        .tree-container { height: 70vh; min-height: 220px; }
        svg line, svg path { stroke-width: 1.2; }
      }

      .controls {
        margin-top: 30px;
        display: flex;
        gap: 15px;
      }

      button {
        padding: 12px 25px;
        border: none;
        border-radius: 30px;
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-3px);
      }

      .instructions {
        margin-top: 20px;
        color: rgba(255, 255, 255, 0.8);
        text-align: center;
        max-width: 600px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Tournament Tree - Knockout System</h1>
      <p class="description">
        Use the slider to progress through tournament rounds. Winners advance to
        the next level!
      </p>
    </div>

    <div class="slider-container">
      <label class="slider-label">Tournament Levels</label>
      <input
        type="range"
        min="0"
        max="4"
        value="0"
        class="tournament-slider"
        id="slider"
      />
      <div class="round-info" id="roundInfo">
        Level 4 nodes & all paths visible
      </div>
    </div>

    <div class="tree-container">
      <svg id="tree-svg"></svg>

      <!-- Root node -->
      <div class="node root" data-level="0">Winner</div>

      <!-- Level 1 nodes -->
      <div class="node node-a" data-level="1">Semi Final A</div>
      <div class="node node-b" data-level="1">Semi Final B</div>

      <!-- Level 2 nodes (children of A and B) -->
      <div class="node node-a1" data-level="2">Quarter A1</div>
      <div class="node node-a2" data-level="2">Quarter A2</div>
      <div class="node node-b1" data-level="2">Quarter B1</div>
      <div class="node node-b2" data-level="2">Quarter B2</div>

      <!-- Level 3 nodes -->
      <div class="node node-a1-1" data-level="3">Round A1-1</div>
      <div class="node node-a1-2" data-level="3">Round A1-2</div>
      <div class="node node-a2-1" data-level="3">Round A2-1</div>
      <div class="node node-a2-2" data-level="3">Round A2-2</div>

      <div class="node node-b1-1" data-level="3">Round B1-1</div>
      <div class="node node-b1-2" data-level="3">Round B1-2</div>
      <div class="node node-b2-1" data-level="3">Round B2-1</div>
      <div class="node node-b2-2" data-level="3">Round B2-2</div>

      <!-- Level 4 nodes (leaf nodes) -->
      <div class="node node-a1-1-1" data-level="4">Man City</div>
      <div class="node node-a1-1-2" data-level="4">Arsenal</div>
      <div class="node node-a1-2-1" data-level="4">Liverpool</div>
      <div class="node node-a1-2-2" data-level="4">Chelsea</div>
      <div class="node node-a2-1-1" data-level="4">Man United</div>
      <div class="node node-a2-1-2" data-level="4">Tottenham</div>
      <div class="node node-a2-2-1" data-level="4">Newcastle</div>
      <div class="node node-a2-2-2" data-level="4">Brighton</div>

      <div class="node node-b1-1-1" data-level="4">Aston Villa</div>
      <div class="node node-b1-1-2" data-level="4">West Ham</div>
      <div class="node node-b1-2-1" data-level="4">Wolves</div>
      <div class="node node-b1-2-2" data-level="4">Crystal Palace</div>
      <div class="node node-b2-1-1" data-level="4">Brentford</div>
      <div class="node node-b2-1-2" data-level="4">Fulham</div>
      <div class="node node-b2-2-1" data-level="4">Everton</div>
      <div class="node node-b2-2-2" data-level="4">Nottingham</div>
    </div>

    <div class="controls">
      <button id="reset-tournament">Reset Tournament</button>
      <button id="auto-play">Auto Play</button>
    </div>

    <div class="instructions">
      <p>
        Move the slider to advance through tournament rounds. Each round,
        winners are randomly selected to advance to the next level. The
        tournament continues until either A or B reaches the root position X.
      </p>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const svg = document.getElementById("tree-svg");
        const slider = document.getElementById("slider");
        const roundInfo = document.getElementById("roundInfo");
        const resetBtn = document.getElementById("reset-tournament");
        const autoPlayBtn = document.getElementById("auto-play");

        let currentRound = 0;
        let winners = {}; // Store winners for each round
        let isAutoPlaying = false;

        // Get all nodes
        const nodes = {};
        document.querySelectorAll(".node").forEach((node) => {
          const classList = Array.from(node.classList);
          const nodeClass = classList.find((cls) => cls !== "node");
          nodes[nodeClass] = node;
        });

        // Define the tournament structure
        const tournamentStructure = {
          4: [
            "node-a1-1-1",
            "node-a1-1-2",
            "node-a1-2-1",
            "node-a1-2-2",
            "node-a2-1-1",
            "node-a2-1-2",
            "node-a2-2-1",
            "node-a2-2-2",
            "node-b1-1-1",
            "node-b1-1-2",
            "node-b1-2-1",
            "node-b1-2-2",
            "node-b2-1-1",
            "node-b2-1-2",
            "node-b2-2-1",
            "node-b2-2-2",
          ],
          3: [
            "node-a1-1",
            "node-a1-2",
            "node-a2-1",
            "node-a2-2",
            "node-b1-1",
            "node-b1-2",
            "node-b2-1",
            "node-b2-2",
          ],
          2: ["node-a1", "node-a2", "node-b1", "node-b2"],
          1: ["node-a", "node-b"],
          0: ["root"],
        };

        // Define level mapping for paths based on child node level
        const pathLevels = {
          "root-node-a": 0,
          "root-node-b": 0,
          "node-a-node-a1": 1,
          "node-a-node-a2": 1,
          "node-b-node-b1": 1,
          "node-b-node-b2": 1,
          "node-a1-node-a1-1": 2,
          "node-a1-node-a1-2": 2,
          "node-a2-node-a2-1": 2,
          "node-a2-node-a2-2": 2,
          "node-b1-node-b1-1": 2,
          "node-b1-node-b1-2": 2,
          "node-b2-node-b2-1": 2,
          "node-b2-node-b2-2": 2,
          "node-a1-1-node-a1-1-1": 3,
          "node-a1-1-node-a1-1-2": 3,
          "node-a1-2-node-a1-2-1": 3,
          "node-a1-2-node-a1-2-2": 3,
          "node-a2-1-node-a2-1-1": 3,
          "node-a2-1-node-a2-1-2": 3,
          "node-a2-2-node-a2-2-1": 3,
          "node-a2-2-node-a2-2-2": 3,
          "node-b1-1-node-b1-1-1": 3,
          "node-b1-1-node-b1-1-2": 3,
          "node-b1-2-node-b1-2-1": 3,
          "node-b1-2-node-b1-2-2": 3,
          "node-b2-1-node-b2-1-1": 3,
          "node-b2-1-node-b2-1-2": 3,
          "node-b2-2-node-b2-2-1": 3,
          "node-b2-2-node-b2-2-2": 3,
        };

        // i created a function to get path level from node relationships
        function getPathLevel(parent, child) {
          // level 4 connections (leaf to level 3)
          if (
            child.includes("-1-1") ||
            child.includes("-2-1") ||
            child.includes("-1-2") ||
            child.includes("-2-2")
          ) {
            return 4;
          }
          // level 3 connections (level 3 to level 2)
          if (child.includes("-1") || child.includes("-2")) {
            if (!child.includes("-1-") && !child.includes("-2-")) {
              return 3;
            }
          }
          // level 2 connections (level 2 to level 1)
          if (
            child === "node-a1" ||
            child === "node-a2" ||
            child === "node-b1" ||
            child === "node-b2"
          ) {
            return 2;
          }
          // level 1 connections (level 1 to root)
          if (child === "node-a" || child === "node-b") {
            return 1;
          }
          return 0;
        }

        // i created a function to get node level from node class
        function getNodeLevel(nodeClass) {
          if (nodeClass === "root") {
            return 0;
          }
          if (nodeClass === "node-a" || nodeClass === "node-b") {
            return 1;
          }
          if (
            nodeClass === "node-a1" ||
            nodeClass === "node-a2" ||
            nodeClass === "node-b1" ||
            nodeClass === "node-b2"
          ) {
            return 2;
          }
          if (nodeClass.includes("-1") || nodeClass.includes("-2")) {
            if (!nodeClass.includes("-1-") && !nodeClass.includes("-2-")) {
              return 3;
            }
          }
          if (
            nodeClass.includes("-1-1") ||
            nodeClass.includes("-2-1") ||
            nodeClass.includes("-1-2") ||
            nodeClass.includes("-2-2")
          ) {
            return 4;
          }
          return 4;
        }

        // Define parent-child relationships for connections
        const relationships = [
          { parent: "root", child: "node-a" },
          { parent: "root", child: "node-b" },
          { parent: "node-a", child: "node-a1" },
          { parent: "node-a", child: "node-a2" },
          { parent: "node-b", child: "node-b1" },
          { parent: "node-b", child: "node-b2" },
          { parent: "node-a1", child: "node-a1-1" },
          { parent: "node-a1", child: "node-a1-2" },
          { parent: "node-a2", child: "node-a2-1" },
          { parent: "node-a2", child: "node-a2-2" },
          { parent: "node-b1", child: "node-b1-1" },
          { parent: "node-b1", child: "node-b1-2" },
          { parent: "node-b2", child: "node-b2-1" },
          { parent: "node-b2", child: "node-b2-2" },
          { parent: "node-a1-1", child: "node-a1-1-1" },
          { parent: "node-a1-1", child: "node-a1-1-2" },
          { parent: "node-a1-2", child: "node-a1-2-1" },
          { parent: "node-a1-2", child: "node-a1-2-2" },
          { parent: "node-a2-1", child: "node-a2-1-1" },
          { parent: "node-a2-1", child: "node-a2-1-2" },
          { parent: "node-a2-2", child: "node-a2-2-1" },
          { parent: "node-a2-2", child: "node-a2-2-2" },
          { parent: "node-b1-1", child: "node-b1-1-1" },
          { parent: "node-b1-1", child: "node-b1-1-2" },
          { parent: "node-b1-2", child: "node-b1-2-1" },
          { parent: "node-b1-2", child: "node-b1-2-2" },
          { parent: "node-b2-1", child: "node-b2-1-1" },
          { parent: "node-b2-1", child: "node-b2-1-2" },
          { parent: "node-b2-2", child: "node-b2-2-1" },
          { parent: "node-b2-2", child: "node-b2-2-2" },
        ];

        function updateRoundInfo(round) {
          const roundNames = [
            "Level 4 nodes & all paths visible",
            "Level 3 nodes & level 4 paths hidden",
            "Level 2 nodes & level 3-4 paths hidden",
            "Level 1 nodes & level 2-4 paths hidden",
            "Final: Root, A, B nodes only",
          ];
          roundInfo.textContent = roundNames[round] || "All nodes hidden";
        }

        function updateNodeVisibility(level) {
          // i show only nodes at the specific level selected, root always visible
          Object.values(nodes).forEach((node) => {
            const classList = Array.from(node.classList);
            const nodeClass = classList.find(
              (cls) => cls !== "node" && cls !== "visible" && cls !== "winner"
            );

            if (nodeClass) {
              const nodeLevel = getNodeLevel(nodeClass);

              // reset all classes first
              node.classList.remove("visible", "winner");

              // root node (level 0) is always visible
              if (nodeLevel === 0) {
                node.classList.add("visible");
              } else {
                // show only nodes at the specific level based on slider (0-3 range)
                const targetLevel = 4 - level;
                if (nodeLevel === targetLevel) {
                  node.classList.add("visible");
                }
              }
            }
          });
        }

        function updatePathVisibility(level) {
          // i implemented this to control which path levels are visible based on the slider
          document.querySelectorAll("line, path").forEach((connection) => {
            const parent = connection.getAttribute("data-parent");
            const child = connection.getAttribute("data-child");

            if (parent && child) {
              const pathLevel = getPathLevel(parent, child);

              // remove existing level classes and hidden class
              connection.classList.remove(
                "hidden",
                "level-0",
                "level-1",
                "level-2",
                "level-3",
                "level-4"
              );
              connection.classList.add(`level-${pathLevel}`);

              // hide paths from highest level (4) down to the specified level (but not beyond level 2)
              if (pathLevel >= 4 - level + 1) {
                connection.classList.add("hidden");
              }
            }
          });
        }

        function selectWinners(currentLevel, nextLevel) {
          // Group current level nodes by their parent
          const groups = {};

          relationships.forEach((rel) => {
            if (tournamentStructure[nextLevel].includes(rel.parent)) {
              if (!groups[rel.parent]) {
                groups[rel.parent] = [];
              }
              if (tournamentStructure[currentLevel].includes(rel.child)) {
                groups[rel.parent].push(rel.child);
              }
            }
          });

          // Select one winner from each group
          const winners = [];
          Object.keys(groups).forEach((parent) => {
            const candidates = groups[parent];
            if (candidates.length > 0) {
              const winner =
                candidates[Math.floor(Math.random() * candidates.length)];
              winners.push({ winner, parent, candidates });
            }
          });

          return winners;
        }

        function updateTournament(round) {
          // i control both node and path visibility together
          updateNodeVisibility(round);
          updateNodePositions(round);
          updatePathVisibility(round);
          updateRoundInfo(round);
        }

        function updateNodePositions(round) {
             // i animate node positions based on tournament round
             const level1NodesLeft = ['node-a'];
             const level1NodesRight = ['node-b'];
             const level2NodesLeft = ['node-a1', 'node-a2'];
             const level2NodesRight = ['node-b1', 'node-b2'];
             const level3NodesLeft = [
               'node-a1-1', 'node-a1-2', 'node-a2-1', 'node-a2-2'
             ];
             const level3NodesRight = [
               'node-b1-1', 'node-b1-2', 'node-b2-1', 'node-b2-2'
             ];
   
             if (round >= 4) {
                // final round: scale root node and move A, B closer
                const rootNode = nodes['root'];
                if (rootNode) {
                  rootNode.style.transform = 'translate(-50%, -50%) scale(1.5)';
                }
                
                level1NodesLeft.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.left = '40%';
                  }
                });
                
                level1NodesRight.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.left = '60%';
                  }
                });
                
                // hide all other levels
                level2NodesLeft.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'none';
                  }
                });
                
                level2NodesRight.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'none';
                  }
                });
                
                level3NodesLeft.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'none';
                  }
                });
                
                level3NodesRight.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'none';
                  }
                });
              } else if (round >= 3) {
                // reset root node scale
                const rootNode = nodes['root'];
                if (rootNode) {
                  rootNode.style.transform = 'translate(-50%, -50%) scale(1)';
                }
                
                // show all nodes
                [...level2NodesLeft, ...level2NodesRight, ...level3NodesLeft, ...level3NodesRight].forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'flex';
                  }
                });
               // move level 1 nodes to edge positions
               level1NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '12%';
                  
                 }
               });
               
               level1NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '88%';
                 }
               });
               
               // keep level 2 nodes at edge positions
               level2NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '12%';
                 }
               });
               
               level2NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '88%';
                 }
               });
               
               // keep level 3 nodes at edge positions
               level3NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '12%';
                 }
               });
               
               level3NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '88%';
                 }
               });
             } else if (round >= 2) {
              // move level 2 nodes to edge positions
              level2NodesLeft.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '12%';
                }
              });
              
              level2NodesRight.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '88%';
                }
              });
              
              // keep level 3 nodes at edge positions
              level3NodesLeft.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '12%';
                }
              });
              
              level3NodesRight.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '88%';
                }
              });
            } else if (round >= 1) {
               // reset level 1 to original positions
               level1NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '36%';
                 }
               });
               
               level1NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '64%';
                 }
               });
               
               // reset level 2 to original positions
               level2NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '32%';
                 }
               });
               
               level2NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '68%';
                 }
               });
              
              // move level 3 nodes to edge positions
              level3NodesLeft.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '12%';
                }
              });
              
              level3NodesRight.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '88%';
                }
              });
            } else {
                // reset root node scale
                const rootNode = nodes['root'];
                if (rootNode) {
                  rootNode.style.transform = 'translate(-50%, -50%) scale(1)';
                }
                
                // show all nodes
                [...level2NodesLeft, ...level2NodesRight, ...level3NodesLeft, ...level3NodesRight].forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.display = 'flex';
                  }
                });
                
                // reset all to original positions
                level1NodesLeft.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.left = '36%';
                  }
                });
                
                level1NodesRight.forEach(nodeClass => {
                  const node = nodes[nodeClass];
                  if (node) {
                    node.style.left = '64%';
                  }
                });
               
               level2NodesLeft.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '32%';
                 }
               });
               
               level2NodesRight.forEach(nodeClass => {
                 const node = nodes[nodeClass];
                 if (node) {
                   node.style.left = '68%';
                 }
               });
              
              level3NodesLeft.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '30%';
                }
              });
              
              level3NodesRight.forEach(nodeClass => {
                const node = nodes[nodeClass];
                if (node) {
                  node.style.left = '70%';
                }
              });
            }
            
            // redraw connections after position changes but preserve visibility
            drawConnections();
            // reapply path visibility after redrawing
            setTimeout(() => {
              updatePathVisibility(currentRound);
            }, 10);
          }

        function progressTournament(targetRound) {
          for (let round = currentRound + 1; round <= targetRound; round++) {
            if (round <= 4) {
              const currentLevel = 5 - round;
              const nextLevel = currentLevel - 1;

              if (nextLevel >= 0) {
                winners[round] = selectWinners(currentLevel, nextLevel);
              }
            }
          }
          currentRound = targetRound;
          updateTournament(currentRound);
        }

        // Slider event listeners
        slider.addEventListener("input", (e) => {
          if (!isAutoPlaying) {
            const targetRound = parseInt(e.target.value);
            currentRound = targetRound;
            updateTournament(currentRound);
          }
        });

        function resetTournament() {
          currentRound = 0;
          winners = {};
          slider.value = 0;
          updateTournament(0);
          drawConnections();
        }

        function drawConnections() {
          svg.innerHTML = "";

          relationships.forEach((rel) => {
            const parentNode = nodes[rel.parent];
            const childNode = nodes[rel.child];

            if (!parentNode || !childNode) return;

            const parentRect = parentNode.getBoundingClientRect();
            const childRect = childNode.getBoundingClientRect();
            const containerRect = svg.getBoundingClientRect();

            const parentCenter = {
              x: parentRect.left + parentRect.width / 2 - containerRect.left,
              y: parentRect.top + parentRect.height / 2 - containerRect.top,
            };

            const childCenter = {
              x: childRect.left + childRect.width / 2 - containerRect.left,
              y: childRect.top + childRect.height / 2 - containerRect.top,
            };

            let element;
            if (rel.parent === "root") {
              element = drawStraightLine(parentCenter, childCenter);
            } else {
              element = drawLShapedLine(parentCenter, childCenter);
            }

            element.setAttribute("data-parent", rel.parent);
            element.setAttribute("data-child", rel.child);

            // i added level classification for path visibility control
            const pathLevel = getPathLevel(rel.parent, rel.child);
            element.classList.add(`level-${pathLevel}`);
          });
        }

        function drawLShapedLine(from, to) {
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          const isLeftSide = to.x < from.x;

          let pathData;
          if (isLeftSide) {
            const midX = from.x - Math.abs(from.x - to.x) * 0.2;
            pathData = `M ${from.x} ${from.y} H ${midX} V ${to.y} H ${to.x}`;
          } else {
            const midX = from.x + Math.abs(from.x - to.x) * 0.2;
            pathData = `M ${from.x} ${from.y} H ${midX} V ${to.y} H ${to.x}`;
          }

          path.setAttribute("d", pathData);
          svg.appendChild(path);
          return path;
        }

        function drawStraightLine(from, to) {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", from.x);
          line.setAttribute("y1", from.y);
          line.setAttribute("x2", to.x);
          line.setAttribute("y2", to.y);
          svg.appendChild(line);
          return line;
        }

        // Reset button
        resetBtn.addEventListener("click", resetTournament);

        // Auto play functionality
        autoPlayBtn.addEventListener("click", () => {
          if (isAutoPlaying) {
            isAutoPlaying = false;
            autoPlayBtn.textContent = "Auto Play";
          } else {
            isAutoPlaying = true;
            autoPlayBtn.textContent = "Stop";
            autoPlay();
          }
        });

        function autoPlay() {
          if (!isAutoPlaying || currentRound >= 4) {
            isAutoPlaying = false;
            autoPlayBtn.textContent = "Auto Play";
            return;
          }

          setTimeout(() => {
            slider.value = currentRound + 1;
            progressTournament(currentRound + 1);
            if (isAutoPlaying) {
              autoPlay();
            }
          }, 1500);
        }

        // Initialize
        resetTournament();
        
        // redraw connections on window resize and when the tree container changes size
        window.addEventListener('resize', drawConnections);

        // Prefer ResizeObserver for robust responsiveness (observes the tree container)
        const treeContainer = document.querySelector('.tree-container');
        if (window.ResizeObserver) {
          const ro = new ResizeObserver(() => {
            // small debounce to avoid too many redraws
            if (this._drawTimeout) clearTimeout(this._drawTimeout);
            this._drawTimeout = setTimeout(() => drawConnections(), 50);
          });
          ro.observe(treeContainer);
        }
      });
    </script>
  </body>
</html>
